mod file;
mod wave;

use std::collections::VecDeque;
#[derive(Debug)]
struct Track {
	instr: file::Instrument,
	notes: VecDeque<file::Note>,

	panning:  f64,
	volume:   f64,
	rsamples: usize,
	wavepos:  f64,
	wavespd:  f64,
}
impl Track {
	fn new(
		instr: file::Instrument, 
		mut notes: Vec<file::Note>) -> Self {

		/* Sort the notes by position and put them in a queue. */
		notes.sort_by(|a, b| u32::cmp(&a.position, &b.position));
		
		Track {
			instr,
			notes:    From::from(notes),
			panning:  0.0,
			volume:   1.0,
			rsamples: 0,
			wavepos:  0.0,
			wavespd:  0.0,
		}
	}
}

#[derive(Debug)]
pub enum Error {
	MissingWavetable,
	InvalidWavetable,
	InvalidTracks,
	IoError(std::io::Error)
}

use std::borrow::Cow;
#[derive(Debug)]
pub struct Player {
	waves: Vec<i16>,
	track: Vec<Track>,
	sbeat: usize,
	bmsec: f64,
	cbeat: usize,
}

use std::io::Read;
impl Player {
	pub fn new<R: Read>(samplerate: usize, mut org: R, wave: Option<R>) 
		-> Result<Self, Error> {

		let organya = file::read(&mut org).map_err(|what| Error::IoError(what))?;
		let file::Organya {
			file_header: header, 
			instruments: instrs,
			note_events: notes 
		} = organya;

		let track = instrs.iter()
			.zip(notes.iter())
			.map(|(instr, notes)| Track::new(*instr, notes.to_vec()))
			.collect::<Vec<Track>>();
		if track.len() != 16 { return Err(Error::InvalidTracks) }
		
		let waves = {
			let mut vec = Vec::new();
			match wave {
				Some(mut stream) => { 
					stream.read_to_end(&mut vec).map_err(|what| Error::IoError(what))?;
				},
				None => {
					use std::io::Cursor;
					let mut stream = Cursor::new(wave::WAVETABLE
						.ok_or(Error::MissingWavetable)?);
					stream.read_to_end(&mut vec).map_err(|what| Error::IoError(what))?;
				}
			};
			vec.chunks_exact(2)
				.map(|chunk| {
					use std::convert::TryInto;
					i16::from_le_bytes(chunk.try_into().unwrap())
				})
				.collect::<Vec<i16>>()
		};

		/* Get some diagnostics on the wavetable. */
		{
			use wave::Wavetable;
			let table = Wavetable(&waves);
			if !table.whole() {
				warn!("The given wave table isn't whole.");
			}
			if table.len() < 100 {
				return Err(Error::InvalidWavetable)
			}
			if table.len() > 100 {
				debug!("The given wave table has {} entries. Expected 100.",
					table.len());
			}
		}

		Ok(Self {
			waves,
			track,
			sbeat: (samplerate * usize::from(header.wait())) / 1000,
			bmsec: 1.0 / f64::from(header.wait()),
			cbeat: 0,
		})
	}

	pub fn samples_per_beat_channel(&self) -> usize {
		self.sbeat
	}

	pub fn synth(&mut self, buff: &mut [f64]) -> usize {
		use wave::Wavetable;
		let table = Wavetable(&self.waves);

		let sbeat = self.sbeat;
		let spsec = self.sbeat as f64 * self.bmsec as f64 * 1000.0;
		let process = |buff: &mut [f64], beat: usize, track: &mut Track| {
			/* Process the track and generate enough samples for one beat. */
			let event = track.notes.front().map(|e| e.position as usize <= beat);
			if let Some(true) = event {
				let event = track.notes.pop_front().unwrap();
				trace!("Got event {:?}", event);
				if event.volume != 0xff {
					/* The volume value ranges from 0 being no sound to 254
					 * being max volume. Here, we map that to the 0.0 to 1.0
					 * range. */
					let v = f64::from(event.volume) / f64::from(u8::MAX - 1);
					track.volume = v;
				}
				if event.panning != 0xff {
					/* The panning value ranges from 0 to 12, with 0 being
					 * full left pan, 6 being center and 12 being full right
					 * pan. Here, we map that to the -1.0 to 1.0 range, with
					 * -1.0 being full left pan, 0.0 being center and 1.0
					 * being full right pan. */
					track.panning = (f64::from(event.panning) - 6.0) / 6.0;
				}
				if event.value != 0xff {
					/* How do we determine the next sample to be played? 
					 * 
					 * Well, each wave sample is one complete period, so, we
					 * just play the wave sample back X times per second, where
					 * X is frequency of the note in Hertz. To figure the 
					 * frequency of a given note out, however, we need to first
					 * figure out the key this note is in, for that, we know
					 * that the note value can range from 0 to 95, with 45
					 * being A3 = 440Hz. From that, we can use equal temperament
					 * to figure out the other note frequencies. */
					/*let freq = 440.0 * f64::powi(1.0594630943592953, event.value as i32 - 45);*/
					let freq = f64::powf(
						2.0, 
						(f64::from(event.value) + f64::from(track.instr.pitch()) / 1000.0 + 155.376) / 12.0) / 2.0;
					track.wavespd = freq / spsec;
					track.wavepos = 0.0;

					/* The number of samples we still have left to play is */
					track.rsamples = if track.instr.sustn() > 0 {
						1024 
					} else {
						usize::from(event.length) * sbeat
					}
				}
				/* There is no separate check for event.length because in the
				 * OrgPlay program the length value of a note only has any
				 * effect when coupled with a note value change. */
			}

			for i in 0..usize::min(sbeat, track.rsamples) {
				/*let sample = f64::from({
					let x = track.wavepos;

					/* Apply Lanczos filtering */
					let radius  = 2.0;
					let lanczos = |n: f64| 
						if n == 0.0 { 
							1.0 
						} else if n.abs() > radius {
							0.0
						} else {
							let c  = n * std::f64::consts::PI;
							let cr = c / radius;
							f64::sin(c) * f64::sin(cr) / (c * cr)
						};

					let scale  = if 1.0 / track.wavespd > 1.0 { 1.0 } else { 1.0 / track.wavespd };
					let min    = (-radius / scale + x - 0.5).round();
					let max    = ( radius / scale + x + 0.5).round();

					let table = table.get(usize::from(track.instr.instr()) % table.len()).unwrap();
					let (density, sample): (f64, f64) = (min as usize..max as usize)
						.fold((0.0, 0.0), |(density, sample), m| {
							let m = m as f64;
							let factor = lanczos((m as f64 - x + 0.5) * scale);

							let m = if m < 0.0 { 0.0 } else { m };
							let m = table.get(m as usize % table.len()).unwrap();
							let m = *m as f64;

							(
								density + factor,
								sample + m * factor
							)
						});
					let sample = if density > 0.0 { sample / density } else { sample };

					track.wavepos += track.wavespd;
					track.wavepos %= table.len() as f64;
					sample
				});*/
				let sample = {
					let wave = table.get(usize::from(track.instr.instr()) % table.len()).unwrap();
					let sample = wave[track.wavepos.round() as usize % wave.len()];

					track.wavepos += track.wavespd;
					track.wavepos %= table.len() as f64;
					f64::from(sample) / f64::from(i16::MAX)
				};
				let l = sample * if 1.0 - track.panning > 1.0 { 1.0 } else { 1.0 - track.panning };
				let r = sample * if 1.0 + track.panning > 1.0 { 1.0 } else { 1.0 + track.panning };
				
				/*let sample = if sample >  1.0 {  1.0 } else { sample };
				let sample = if sample < -1.0 { -1.0 } else { sample };*/

				buff[i * 2 + 0] += l * track.volume;
				buff[i * 2 + 1] += r * track.volume;

				if track.rsamples > 0 { track.rsamples -= 1; }
			}
		};
		
		let beats = buff.len() / self.sbeat / 2;
		for beat in 0..beats {
			trace!("Generating beat {}", self.cbeat + beat);
			let slice = &mut buff[beat * self.sbeat * 2..(beat + 1) * self.sbeat * 2];
			
			for sample in slice.iter_mut() {
				*sample = 0.0;
			}
			
			let cbeat   = self.cbeat;
			let track   = &mut self.track[1..2];
			let tracks  = track.len();
			let samples = track.iter_mut()
				.map(|mut track| {
					let mut slice = vec![0.0; slice.len()];
					process(&mut slice[..], cbeat + beat, track);
					slice
				})
				.collect::<Vec<_>>();

			samples.into_iter()
				.fold(slice, |slice, track| {
					slice.iter_mut()
						.zip(track.into_iter())
						.for_each(|(tgt, src)| *tgt += src / tracks as f64);
					slice	
				});
		}
		self.cbeat += beats;

		beats * self.sbeat * 2
	}
}

