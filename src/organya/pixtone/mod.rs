/*! Tools for generation of PixTone waveforms.
 *
 * PixTone, by specification, generates its output at a sampling rate of 22050Hz
 * which means the waves generated by this module are also sampled at 22050Hz.*/

/** Utilities for parsing. */
mod file;
pub use file::Error as ParseError;

const SAMPLE_RATE: usize = 22050;

/** Static built-in wave data, generated at build time by `build/organya/mod.rs` */
const WAVEFORMS: [[i8; 256]; 6] = 
	include!(concat!(env!("OUT_DIR"), "/organya/pixtone_waveforms"));

/** Static built-in pixtone sample generation files. */
pub const EFFECTS: Option<&'static [(usize, &'static [u8])]> = 
	include!(concat!(env!("OUT_DIR"), "/organya/pixtone_effects"));

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[repr(u8)]
#[allow(dead_code)]
enum Waveform {
	Sine		= 0,
	Triangle	= 1,
	SawUp		= 2,
	SawDown		= 3,
	Square		= 4,
	Random		= 5,
}
impl Waveform {
	/** Get the sample data for this wave form. */
	pub fn data(&self) -> &'static [i8] {
		&WAVEFORMS[*self as usize]
	}
}
use std::convert::TryFrom;
impl TryFrom<u8> for Waveform {
	type Error = u8;
	fn try_from(i: u8) -> Result<Self, Self::Error> {
		match i {
			0 => Ok(Waveform::Sine),
			1 => Ok(Waveform::Triangle),
			2 => Ok(Waveform::SawUp),
			3 => Ok(Waveform::SawDown),
			4 => Ok(Waveform::Square),
			5 => Ok(Waveform::Random),
			_ => Err(i)
		}
	}
}

#[derive(Copy, Clone, PartialEq, PartialOrd)]
struct WaveDescriptor {
	/** Number of the base wave in PixTone. */
	waveform: Waveform,
	/** Offset in samples from the start of the wave. */
	offset: u8,
	/** Frequency at which this wave will be playing, in hertz. */
	freq: f64,
	/** Top as in maximum value? */
	max: u8
}

struct Envelope {
	/** Volume at the beggining of the envelope. */
	initial: u8,
	/** Time and volume at the end of the attack phase. */
	attack: (u8, u8),
	/** Time and volume at the end of the decay phase. */
	decay: (u8, u8),
	/** Time and volume at the end of the sustain phase. */
	sustain: (u8, u8)
}
impl Envelope {
	/** Apply the envelope effect over a sample generator, assuming the final
	 * size of the generated wave is length, expressed in samples. */
	fn over<'a, S>(
		&'a self, 
		wave: S, 
		length: usize) -> EnvelopeOver<'a, S> where S: Iterator<Item = i8> {
		
		EnvelopeOver {
			envelope: self,
			samples:  wave,
			length,
			sample: 0
		}
	}
}

struct Channel {
	/** Length of the target sample, in samples. */
	len: usize,
	/** Envelope of the current channel. */
	envelope: Envelope,
	/** Base wave to be modulated by the amplitude and frequency waves. */
	base: WaveDescriptor,
	/** Signal wave for amplitude modulation. */
	ampl: WaveDescriptor,
	/** Signal wave for frequency modulation. */
	freq: WaveDescriptor,
}
impl Channel {
	fn synth<'a>(&'a self) -> impl Iterator<Item = i8> + 'a {
		let channel = ChannelSynth {
			data: self,
			amplpos: f64::from(self.ampl.offset),
			freqpos: f64::from(self.freq.offset),
			wavepos: 0.0,
			sample:  0
		};
		self.envelope.over(channel, self.len)
	}
}

#[derive(Debug)]
pub enum Error {
	Parse(ParseError),
	InvalidWaveform(u8),
}

use std::io::Read;
pub struct Synth {
	/** Channel data for each channel. */
	channels: Vec<Channel>,
	/** Current sample. */
	sample: usize,
	/** Maximum length among all the channels. */
	length: usize,
}
impl Synth {
	pub fn new<R: Read>(r: R) -> Result<Self, Error> {
		let buf  = std::io::BufReader::new(r);
		let file = file::parse_pxt(buf).map_err(|w| Error::Parse(w))?;

		let channels = file.iter()
			.filter(|chan| chan.r#use.unwrap() != 0)
			.map(|chan| Ok(Channel {
				len:  chan.size.unwrap(),
				base: WaveDescriptor {
					waveform: Waveform::try_from(chan.main_model.unwrap())
						.map_err(|w| Error::InvalidWaveform(w))?,
					freq:   chan.main_freq.unwrap(),
					max:    chan.main_top.unwrap(),
					offset: chan.main_offset.unwrap(),
				},
				ampl: WaveDescriptor {
					waveform: Waveform::try_from(chan.volume_model.unwrap())
						.map_err(|w| Error::InvalidWaveform(w))?,
					freq:   chan.volume_freq.unwrap(),
					max:    chan.volume_top.unwrap(),
					offset: chan.volume_offset.unwrap(),
				},
				freq: WaveDescriptor {
					waveform: Waveform::try_from(chan.pitch_model.unwrap())
						.map_err(|w| Error::InvalidWaveform(w))?,
					freq:   chan.pitch_freq.unwrap(),
					max:    chan.pitch_top.unwrap(),
					offset: chan.pitch_offset.unwrap(),
				},
				envelope: Envelope {
					initial:  chan.initial_y.unwrap(),
					attack:  (chan.ax.unwrap(), chan.ay.unwrap()),
					sustain: (chan.bx.unwrap(), chan.by.unwrap()),
					decay:   (chan.cx.unwrap(), chan.cy.unwrap()),
				}
			}))
			.collect::<Result<Vec<_>, Error>>()?;

		let length = channels.iter()
			.fold(0, |l, chan| if chan.len > l { chan.len } else { l });
		
		Ok(Self {
			channels,
			length,
			sample: 0
		})
	}

	/** How many samples have we still got left? */
	pub fn remaining(&self) -> usize {
		self.length - self.sample
	}
	/** Generate some samples, returning how many samples were generated, which
	 * is guaranteed to be such that `0 <= n <= buff.len()`. */
	pub fn generate(&mut self, buff: &mut [i8]) -> usize {
		let mut gens = self.channels.iter().map(|c| c.synth()).collect::<Vec<_>>();
		let mixer    = Mixer(&mut gens[..]);

		let generated = (0..buff.len()).into_iter()
			.zip(mixer.skip(self.sample))
			.fold(0, |offset, (_, sample)| {
				buff[offset] = sample;
				offset + 1
			});

		self.sample += generated;
		generated
	}
}

struct ChannelSynth<'a> {
	/** Channel information used throughout the synth process. */
	data: &'a Channel,
	/** Current position along the amplitude signal. */
	amplpos: f64,
	/** Current position along the frequency signal. */
	freqpos: f64,
	/** Current position along the base wave. */
	wavepos: f64,
	/** Current sample being synthesized. */
	sample: usize,
}
impl<'a> Iterator for ChannelSynth<'a> {
	type Item = i8;
	fn next(&mut self) -> Option<Self::Item> {
		if self.data.len - self.sample == 0 { return None }

		/* Synthesize the next sample in the current channel. */
		let amplspd = self.data.ampl.freq / SAMPLE_RATE as f64;
		let freqspd = self.data.freq.freq / SAMPLE_RATE as f64;
		let wavespd = self.data.base.freq / SAMPLE_RATE as f64;

		let ampl = self.data.ampl.waveform.data();
		let freq = self.data.freq.waveform.data();

		let ampl = f64::from(ampl[self.amplpos as usize % ampl.len()]);
		let freq = f64::from(freq[self.freqpos as usize % freq.len()]);

		let ampl = ampl / f64::from(i8::MAX) * f64::from(self.data.ampl.max);
		let freq = freq / f64::from(i8::MAX);
		let freq = freq * (f64::from(self.data.freq.max) / f64::from(u8::MAX));
		let freq = 1.0 + freq;

		self.amplpos += amplspd;
		self.freqpos += freqspd;

		let sample = self.data.base.waveform.data();
		let sample = f64::from(sample[self.wavepos as usize % sample.len()]);
		let sample = sample + ampl;

		self.wavepos += wavespd;
		self.sample += 1;

		Some(sample as i8)
	}
}

struct EnvelopeOver<'a, S> {
	/** Envelope parameters. */
	envelope: &'a Envelope,
	/** Generator we're taking our samples from. */
	samples: S,
	/** Total length of the final wave, in samples. */
	length: usize,
	/** Current sample. */
	sample: usize,
}
impl<'a, S: Iterator<Item = i8>> Iterator for EnvelopeOver<'a, S> {
	type Item = i8;
	fn next(&mut self) -> Option<Self::Item> {
		let position = self.sample as f64 / self.length as f64;
		
		let attckpos = f64::from(self.envelope.attack.0)  / 256.0;
		let sustnpos = f64::from(self.envelope.sustain.0) / 256.0;
		let decaypos = f64::from(self.envelope.decay.0)   / 256.0;

		let initlval = f64::from(self.envelope.initial)   / 64.0;
		let attckval = f64::from(self.envelope.attack.1)  / 64.0;
		let sustnval = f64::from(self.envelope.sustain.1) / 64.0;
		let decayval = f64::from(self.envelope.decay.1)   / 64.0;

		/* Find out our current phase. */
		let (ax, ay, bx, by) = 
			if      position < attckpos { (0.0,      initlval, attckpos, attckval) }
			else if position < sustnpos { (attckpos, attckval, sustnpos, sustnval) }
			else if position < decaypos { (sustnpos, sustnval, decaypos, decayval) }
			else                        { (decaypos, decayval, 1.0,      0.0)      }; 

		assert!(ax < bx);
		assert!(ax <= position && position <= bx);

		/* Linenarly interpolate between the values of point A and point B. */
		let ix = (position - ax) / (bx - ax);
		let iy = ay + (by - ay) * ix;

		/* Multiply the value by the loudness we've just calculated. */
		let sample = f64::from(self.samples.next()?) * iy;
		Some(sample as i8)
	}
}

/** Mix channels with the same volume. */
struct Mixer<'a, S>(&'a mut [S]);
impl<'a, S: Iterator<Item = i8>> Iterator for Mixer<'a, S> {
	type Item = i8;
	fn next(&mut self) -> Option<Self::Item> {
		let mut value = None;
		for item in self.0.iter_mut() {
			let sample = item.next().and_then(|x| Some(f64::from(x)));
			match value {
				Some(val) => value = Some(val + sample.unwrap_or(0.0)),
				None      => value = sample
			}
		}
		value.and_then(|v| Some((v / self.0.len() as f64) as i8))
	}
}

